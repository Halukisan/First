# 数据结构与算法

> 《数据结构与算法》课程是计算机科学与技术的学科基础课程，不仅是《计算机图形学》、《计算机网络》、《编译原理》、《计算机操作系统》等后续课程的基础理论之一，其应用范围也早已扩展到图像处理与模式识别、海量数据挖掘、科学数据处理、复杂网络分析等许多计算机前沿领域。
>
>    本笔记研究计算机处理数据的结构特性，学习线性表、树、图等常用数据结构的逻辑结构与存储结构；学习分治递归、动态规划、贪心算法等典型算法，掌握分析与推导算法效率的方法。 

[TOC]



# 第一章、数据结构的基本概念

- 主要内容
- 四大逻辑结构
- 基本术语
- 数据结构的表示
- 数据的存储结构
- 算法的基础知识

 

##  1.1、主要内容

> 《数据结构与算法》内容研究

<img src="图片/计算机科学与技术系专业课程图.png" alt="计算机科学与技术系专业课程图" style="zoom:150%;" />



为什么要学习数据结构与算法？

**数据结构的主要内容**

![《数据结构与算法》内容研究](图片/《数据结构与算法》内容研究.png)

**算法及分析方法**



> - [x] 思考
>
> 我们需要计算机来做什么？如何让计算机做？
>
> **程序 = 算法 + 数据结构**，而*算法 = 逻辑 + 控制*
>
> **数据结构**的两大用途：
>
> 一是用于存放要处理的数据，如迷宫地图。
>
> 二是用于**实现算法策略**如迷宫例子中探索方向增量数。



## 1.2、四大逻辑结构

- 四大逻辑结构概述
- 数据逻辑关系分析



### 1.2.1、四大逻辑结构概述

如何表示和存储电话号码簿的所有信息——数据结构设计

如何实现快速查找——算法设计



> 四大逻辑结构

![四大逻辑结构](图片/四大逻辑结构.png)

1. 线性结构：

**线性结构**中的数据元素之间是一对一的关系，如	1->1->1->1->1 

2. 树形结构：

**树形结构**中的数据元素存在一对多的层次关系，如领导可有多个下属

3. 图形结构：

**图形结构**的数据元素是多对多的关系。如《五等分的花嫁》中的多角恋。

4. 集合结构：

**集合结构**中的数据元素除了同属于一个集合外，它们之间没有不三不四的关系，比如搞笑一家人。



### 1.2.2、数据逻辑关系分析

> 分析下面的数据的逻辑关系

**例题1**

$S = (D , R)$

$D = {a, b, c, d, e, f}$

$R = {(a,e),(b,c),(c,a),(e,f),(f,d)}$



![数据逻辑分析例题01](图片/数据逻辑分析例题01.png)

> 分析数据之间的逻辑关系如下：

b ——> c ——> a ——> e ——> f ——> d

√ **线性结构**



**例题2**

$S = (D , R)$

$D = {d i | 1 <= i <= 5}$

$R = {(d i , d j), i < j}$



![数据逻辑分析例题02](图片/数据逻辑分析例题02.png)



> 分析：数据之间的关系

​			d1

d5				d2

​	d4		d3



√ **图形结构/非线性结构**



> Tips： 常见的数据结构有：数组、栈、队列、表、串、树、图和文件等。



## 1.3、基本术语

- 数据相关术语

- 数据结构相关术语



### 1.3.1、数据相关术语

1. 数据（Data）
   所有能被计算机识别的符号集合。

2. 数据元素（Data Element）

   是数据（集合）中的一个“个体”

   是数据结构中讨论的基本单位

3. 数据项（Data Item）
   是数据结构中讨论的最小单位
   数据元素可以是数据项的集合
4. 数据对象（Data Object）
   数据对象是具有相同性质的数据元素的集合，是数据的一个子集。例如：迷宫数据对象中的数据元素是一个个点；电话簿数据对象中数据元素是每个人的记录；图书目录数据对象中数据元素是一张张书目卡片

![数据的结构](图片/数据的结构.png)



### 1.3.2、数据结构相关术语

1. **数据结构（Data Structures）**
   **带结构的数据元素的集合**
   **用集合的形式描述，数据结构是一个二元组：**
   **$DS = (D , R)$**
   **其中：D是数据元素的集合，R是D上关系的集合。**

   **简言之，数据元素和其相互关系称为数据结构。**

2. **数据结构的操作（Operation）**

   **数据元素的查找、插入、删除、遍历和排序**

3. **数据类型（Data Type）**

   **数据类型是程序设计语言中用来刻画操作对象的特性的**

   **一个值的集合和定义在此集合上的一组操作的总称**

![C语言的基本数据类型](图片/C语言的基本数据类型.png)



>- [x] 思考
>
>数据结构与数据类型有什么关系呢？





## 1.4、数据结构的表示

- 抽象数据类型
- 数据结构四元组



### 1.4.1、抽象数据类型

> 抽象数据类型（Abstract Data Type ：ADT）

ADT一般包含数据元素、数据元素之间关系及操作三要素（D, R, O）

其中：

- D是数据元素集
- R是D上的关系集合
- O是对D的基本操作集



> 两大特点

① 抽象性
② 扩展性



> 注释：抽象是指抽取出事物具有的普遍性的本质，它要求抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象还是一种思考问题的方式，它隐藏了繁杂的细节。

```C
抽象数据类型定义格式：
ADT  <抽象数据类型名>
{
数据对象：<数据类型的定义>
数据关系：<数据关系的定义>
基本操作：<基本操作的定义>
} ADT 抽象数据类型名
```

![抽象数据类型与数据结构的关系](图片/抽象数据类型与数据结构的关系.png)

抽象数据类型比起数据结构少了存储（S)



### 1.4.2、数据结构四元组

> 数据结构由一个四元组来表示：

$Data_Structure = (D, L , S, O)$

> 这是数据元素、数据元素之间的逻辑关系，逻辑关系在计算机中的存储表示，以及所规定的操作这四部分
>
> $Data_Structure = (对象，关系，存储，操作)$



D = Data：数据元素的有限集，存储和操作的对象
L = Logical Structure：是数据元素D中数据元素之间客观	存在的关系的有限集。
S = Storage Structure：是数据元素D和数据元素之间的关	系集合L在计算机中的存储表示。
O = Operation：是在数据元素集合D上规定的一组操作





## 1.5、数据的存储结构

—— 传统上，我们把数据结构分为逻辑结构（用于算法分析与设计）和存储结构（实现算法）。

![数据结构的类型](图片/数据结构的类型.png)





> 有两种基本存储结构：

1) 顺序存储结构：把逻辑上相邻的元素存储在物理位置相邻的存储单元中

![顺序存储结构](图片/顺序存储结构.png)

2) 链式存储结构：在数据元素中添加一些地址域或辅助结构，用于存放数据元素之间的关系。

![链式存储结构](图片/链式存储结构.png)



## 1.6、算法的基础知识

- 算法的概念
- 算法的特性
- 算法的性能比较方法
- 算法的时间复杂度
- 渐进分析理论
- 推导大O阶方法







### 1.6.1、算法的概念

算法 —— 解决问题的一种方法



> 算法用途：设计并实现一种用计算机来解决问题的方法

![算法的用途](图片/算法的用途.png)



>算法：是满足下列性质的指令序列。

**→ 输入：有零个或多个外部量作为算法的输入。**
**→ 输出：算法产生至少一个量作为输出。**
**→ 确定性：组成算法的每条指令清晰、无歧义。**
**→ 有限性：算法中每条指令的执行次数有限，执行每条指令的时间也有限。**

![解决问题的过程](图片/解决问题的过程.png)



> 用计算机解决问题的过程

计算机问题求解5步骤：

1. 问题的理解：清楚问题的输入、要求和输出；

2. 数据结构设计：一方面要选择或设计能有效表示和存储应用问题中所涉及的数据对象的数据结构，同时还要选择或设计能支持算法策略实现的数据结构；

3. 算法设计：包括选择算法策略，用适当的方式描述和逐步细化算法步骤；

4. 算法分析：发现有改进完善之处，返回第二步，重新选择或设计数据结构、重新设计算法；

5. 程序实现：用某种计算机程序设计语言，定义数据结构、编写实现算法的代码，在计算机上调试和运行程序



### 1.6.2、算法的特性

> 算法分析

好的算法应该具备以下特性：

- **正确性：**正确性是对算法能否正确求解问题的评价，是首要和最基本的特性；

- **可读性：**可读性是对算法描述的思路、层次的评价。好的算法应该是思路清晰、层次分明、阅读和修改容易；

- **健壮性：**健壮性是对算法在异常情况下处理能力的评价。好的算法在出现异常或非法数据时，在操作不当时，算法都能做适当处理；

- **高效性：**算法的效率是对求解同样问题的不同算法所占用的时间或空间的评价。好的算法应该是高效的，即求解问题所占用存储空间少，执行时间短；

  



> - [x] 思考
>
> 如何来比较算法效率？



### 1.6.3、算法的性能比较方法

1、编程后测试运行时间

2、编程前分析可能的运行时间

![算法性能比较例题](图片/算法性能比较例题.png)



> 算法复杂性分析

算法复杂性是算法运行所需要的计算机资源的量，需要时间资源的量称为**时间复杂性**，需要的空间资源的量称为**空间复杂性**。

这个量应该只依赖于算法要解的规模、算法的输入和算法本身的函数。如果分别用N、I和A表示算法要解问题的规模、算法的输入和算法本身，而且用C表示复杂性，那么，应该有C = F (N,I,A)。一般把时间复杂性和空间复杂性分开，并分别用T和S来表示，则有：T = T(N,I)和S = S(N,I)。（通常让A隐含在复杂性函数名当中） 



> 主要问题：如何将复杂性函数F具体化？

根据$T(N,I)$的概念，他应该是算法在一台抽象的计算机上运行所需要的时间-设此抽象的计算机所提供的的元运算有k 种，分别记为$O1、O2 ...Ok$￥又设每执行一次这些元运算的时间分别为$t1...tk$对于算法A，设统计用到元运算Oi的次数为ei，那么$ei = ei(N,I)$

![算法复杂性分析](图片/算法复杂性分析.png)



> 程序的算法分析方法

抛开软件和硬件因素，只和问题规模有关。编写程序前预先估计算法优劣，改进或者选择最佳算法编程实现

一个算法用程序设计语言表示后，算法就是由一组语句构成，算法的执行效率就由各语句的执行的次数所决定

**作图法**比较各运行时间复杂性

通过给各个复杂性函数带入实际数据并将函数结果绘制成一张图形，可以比较各个*运行时间函数的复杂度。*

![作图法比较各运行时间复杂性](图片/作图法比较各运行时间复杂性.png)



### 1.6.4、算法的时间复杂度

一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，他花费时间就多。一个算法中的语句执行次数（计算步）称为语句频度或时间频度。记为$T(n)$。

一般情况下，算法的基本操作重复执行的次数是模块n的某一个函数$f(n)$，因此，算法的时间复杂度记作：$T(n) = O(f(n))$。

![算法的时间复杂度分析例题01](图片/算法的时间复杂度分析例题01.png)

分析：随着模块$n$的增大，算法执行的时间的增长率和$f(n)$的增长率成正比，所以$f(n)$越小，算法的时间复杂度越低，算法的效率越高

![算法的时间复杂度分析例题02](图片/算法的时间复杂度分析例题02.png)



> 算法复杂性分析过程：

问题提出 → 选用数学模型 → 对$(N,I)$分析 → 渐进分析$T(N,I)$

![分析算法时间复杂度的规定输入](图片/分析算法时间复杂度的规定输入.png)



### 1.6.5、渐近分析理论

> 渐近分析

复杂性渐进性态：
当N单调增加趋于$∞$时，$T(N)$也单调增加趋于$∞$
如果存在T(N)当$N->∞$时有$(T(N) - T(N)) / T(N) -> 0$
那么称$T(N)$是$T(N)$的渐进性态
直观上$T(N)$是$T(N)$中略去低阶项所留下的主项

![渐进分析符号01](图片/渐进分析符号01.png)

![渐进分析符号02](图片/渐进分析符号02.png)



### 1.6.6、推导大O阶方法

> 推导方法

1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且不为1，则去除与这个项相乘的常数
4. 得到的最后结果就是大O阶



> 常用的时间复杂度

常数阶$O(1)$、线性阶$O(N)$、平方阶 $O(N²)$、对数阶$O(log N)$
、立方阶$O(N²)$ 、指数阶$O(2^n)$

常用的时间复杂度所消耗的时间从大到小依次是：
$O(1) < O(log N) < O(N) < O(n log n) < O(N²) < O(N³) < O(2^n) < O(N!) < O(N^n)$



# 第二章、线性表

- 线性表的定义

- 线性表的抽象数据类型

- 线性表的顺序存储结构

- 线性表的链式存储结构

- 栈

- 队列

  





## 2.1、线性表的定义

> 概述

<u>**线性表(Linear List)：n个同类数据元素的有限序列**</u>



记为：
$L = （a1,  a2,  a3,  a4,  a i ...,  an）$
L 为表名；
i为数据元素a i在线性表中的位序；
n为线性表的表长；$n = 0$时称为空表；
数据元素之间的关系是：
$a i-1$ 领先于$a i$ , a i领先于$a i+1$。
称$a i-1$是$a i$ 的直接前驱，$a i+1$是$a i$的直接后继。
除第一元素$a1$外，均有唯一的前驱；
除最后元素$an$外，均有唯一的后继；



> 特点：

==a i 的数据类型相同==
==位序i从1开始==
==前驱与后继==



> 练习题

![线性表练习题](图片/线性表练习题.png)



## 2.2、线性表的抽象数据类型

- 线性表的抽象数据类型定义
- 线性表的基本操作
- 合并线性表
- 合并有序表





### 2.2.1、线性表的抽象数据类型定义

> ADT定义

![线性表的抽象数据类型定义](图片/线性表的抽象数据类型定义.png)



> 基本操作

1. 结构初始化操作

2. 结构销毁操作
3. 引用型操作
4. 加工型操作



### 2.2.2、线性表的基本操作

> Operation

1. 初始化与销毁

```c
Status List_Init(SqListPtr L);
void List_Clear(SqListPtr L);
销毁一个线性表
void List_Destory(SqListPtr L);
初始化操作，建立一个空的线性表L。
InitList(L);				
将线性表清空。
ClearList(L);				
```

2. 引用型操作

```c
判断是否为空表
bool List_Empty (SqListPtr L);
返回线性表的元素个数或者说长度
int List_Size(SqListPtr L);
从线性表L中POS这个位置取出数据，放到elem指针中
Status List_Retrival(SqListPtr L, int pos, ElemType *elem);
List_Retrieve(Lb, i, &elem) → elem(依次从LB中取出第i个元素)
从线性表L中定位elem这个位置，然后把这个位置放到POS中
Status List_Locate(SqListPtr L, ElemType elem, int *pos);
在线性表L中求POS的直接前驱
Status List_Prior(SqListPtr L, int pos, ElemType *elem);
在线性表L当中的POS位置，求POS位置的直接后继
Status List_Next(SqListPtr L, int pos, ElemType elem);
判断线性表是否为空表，若线性表为空，返回true，否则返回false。
ListEmpty(L)：
在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功，
否则，返回0表示失败。
LocateElem(L, e)：
返回线性表L的元素个数。
ListLength(L)：
```

3. 加工型操作

```c
插入
Status List_Insert(SqListPtr L, int pos, ElemType elem);
删除
Status List_delete(SqListPtr L, int pos);
在线性表L中第i个位置插入新元素e。
ListInsert(L, i, e);
删除线性表L中第i个位置元素，并用e返回其值
ListDelete(*L, i, *e);
将线性表L中第i个位置元素返回给e。
GetElem(L, i, *e);
线性表的基本操作测试函数
```

4. 函数返回状态值定义

````c
typedef int Status;

/* 函数返回状态值定义 */
enum status 
{
	success = 0, fail = 1, 
    // 内存分配失败
    fatal = -1,
    // 连续空间访问越界
    range_error = -2
};
````



> 注释：	
>
> 对于不同的应用，线性表的基本操作是不同的，上述操作是最基本的，对于实际问题中涉及的关于线性表的更复杂操作，完全可以用这些基本操作的组合来实现。线性表基本操作实现的就是增删改查这4个对数据的经典操作。



5. 线性表的基本操作测试函数

![线性表的基本操作测试函数](图片/线性表的基本操作测试函数.png)



### 2.2.3、合并线性表

> 例1：合并线性表

问题：集合A和B分别用两个线性表LA和LB表示，求A∪B并用线性表LA表示。



> 算法设计：

**思想：从LB中逐一取出元素，判定该元素是否在LA中，若不在则将该元素插入到LA中。**
细化：到实现程度
——逐一：从第一个到最后一个，计数型循环，前提是需要知道元	素个数（int List_Size(SqListPtr L);线性表的元素个数或者说长度）
——如何取出第i个元素bi？
List_Retrieve(Lb, i, &elem)→elem(依次从LB中取出第i个元素)
——如何判断bi是否已在LA中？
List_Locate(La, elem, &i) (判断elem是否在LA中)
——如果不在LA中，怎么实现将bi 插入？
List_Insert(La, i, elem) (若不存在，则将elem插入到LA中)

> 合并线性表算法实现

```c
Status List_Union(SqListPtr La, SqListPtr Lb) 
{

    ElemType elem;							/* 存放从Lb中取出的元素 */	
    Status status;							/* 状态代码 */

    Int i, j, len = List_Size(Lb);			/* len存放Lb的元素个数 */

    for(i = 1; i <= len; i++){
    List_Retrieve(Lb, i, &elem);			/* 取出Lb中第i个数据元素 */
    Status =List_Locate(La, elem, &i) ; 	/* 判定是否在La中 */

    If(status != success){					/* 如果不在 */
        Status = List_Insert(La, 1, elem);	/* 插入到第一个位置 */
        If(status != success) break;		/* 插入失败则退出*/
    }else{
        List_Add(La, j, 1);					/* La的第j个元素加1 */
        }
    }
    return status;
}
```



### 2.2.4、合并有序表

> 例2：合并有序表

![合并有序表](图片/合并有序表.png)



> 实现代码：

```c
Status List_Merge(SqListPtr La, SqListPtr Lb, SqListPtr Lc)
{

    ElemType elem1, elem2;
    Status = List_Init(Lc);
    /* i, j, k分别用于指示La,Lb,Lc中当前元素 */
    Int i = 1, j = 1, k = 1;			
    Int n = List_Size(La), m = List_Size(Lb);

    /* 两个表还未处理完 */
    while(i <= n && j <= m){		
        List_Retrieve(La, i, elem1);
        List_Retrieve(Lb, j, &elem2);
        
        if(elem1 < elem2){
            Status = List_Insert(Lc,k,elem1);
            i++;
        } else {
            Status = List_Insert(Lc,k,elem2);
            j++;
        }
        k++;
    }
    
    /* La表还未处理完 */
    while(i <= n){		
        List_Retrieve(La, i, &elem1);
        Status = List_Insert(Lc,k,elem1);
        i++;
        k++;
    }
    /* Lb表还未处理完 */
    while(j <= m)
    {		
        List_Retrieve(Lb, j, &elem2);
        Status = List_Insert(Lc,k,elem2);
        j++;
        k++;
    }
}
```



> 归并2个有序表 	|	链式存储

```c
// 归并2个有序表 | 链式存储
void merge linklist(ListPtr *la, ListPtr *lb, ListPtr *lc){  
    // la和lb为参与合并的两个有序表，lc为结果有序表
    ListPtr pa, pb, pc, tp;
    pa = (*la)->next; 
    pb = (*lb)->next; 
    pc = *la;
    
    while(!pa && !pb){
        
        if(pa->data < pb->data){
            pc->next = pa;
            pc = pa;
            pa = pa->next;
        } else if(pa->data > pb->data){
            pc->next = pb;
            pc = pb;
            pb = pb->next;
        } else {
            pc->next = pa;
            pc = pa;
            pa = pa->next;
            tp = pb;
            pb = pb->next;
            free(tp);
            tp = NULL; 
        }
    }
    pc->next = (pa? pa : pb);	// 插入剩余段
    free(pb);
    lc = la;
}	// mer-linklist
```

复杂功能 = 基本操作的组合



> 小结：
> 合并线性表只是将一个线性表的元素直接插入到另一个线性表中，而合并有序表是要逐一比较两个表的元素后做插入操作。
>
> 例如直接合并图书馆图书信息是合并线性表，合并几个班学生成绩排名表是合并有序表。





## 2.3、线性表的顺序存储结构

- 顺序存储结构的概念
- 顺序存储结构的实现
- 线性表的创建
- 线性表的查找
- 线性表的插入
- 线性表的删除







### 2.3.1、顺序存储结构的概念

> 线性表的顺序存储结构

用一组地址连续的存储单元依次存放线性表中的数据元素。如数组。线性表的起始地址s称作线性表的基地址。（优点：可随机存储）

![顺序存储结构的元素](图片/顺序存储结构的概念.png)





### 2.3.2、顺序存储结构的实现

> 用结构来整合

**空间如何分配？**
**— 静态：数组，栈上分配内存，但不宜过大，最好不超过1000个元素**
**— 动态：指针，动态分配堆内存，可以分配很大的内存，但是使用完要释放堆内存**



### 2.3.3、线性表的创建

> 创建线性表的实现：

```c
#define List_INIT_SIZE 100		// 线性表的空间大小
#define List_INCERAMENT 10		// 每次增加的数量

typedef int ElemType;

typedef struct SqList	// 线性表的结构
{
    ElemType *elem;		// 一大块连续存储空间的首地址指针
    int length;			// 线性表的长度
    Int list_size;		// 线性表的空间大小
}SqList,*Ptr;

Typedef Ptr SqListPtr;

线性表顺序存储操作的实现
①初始化——创建线性表
Status List_Init(SqListPtr L)
{
    Status s = success;
    L ->list_size = LIST_INIT_SIZE;
    L->length = 0;
    L->elem = (ElemType *)malloc(sizeof(ElemType)*L->list_size);
    If(L->elem == NULL)
    s = fatal;
    Return s;
}
```



### 2.3.4、线性表的查找

> 按位置查找指定的元素

- 检查位置是否合法？

- 返回相应信息

```c
Status List_Retrial(SqListPtr L, int pos, ElemType *elem)
{
    Status s = range_error;
    if(L){
        if((pos - 1) >= 0 && (pos - 1) < L->length){
        *elem = L->elem[pos - 1];
            s = success;
        }
    } else {
    	s = fatal;
    }
    return s;
}
```



> 按值查找指定的位置	

- 逐个比较

- 复杂度分析

  最好时间复杂度：$O(1)$

  最差时间复杂度：$O(n)$

  平均时间复杂度：$O(n)$

```c
Status List_Locate(SqListPtr L,  ElemType elem, int pos)
{
    Status s = range_error;
    
    if(L){
        // 循环查找元素的位置
        for(int i = 0; i < L->length; ++i)
        {
            if(L->elem[i] == elem){
                *pos = i + 1;
                s = success;
                break;
            }

        }
    }else{
        s = fatal;
    }
    return s;
}
```



### 2.3.5、线性表的插入

> 插入数据操作

第i个元素之前插入新数据元素X

步骤：

- 检查插入位置是否合法，如果合法则继续，否则退出；

- 判断表是否已占满；因为是事先分配空间，可能存在所分配的存储空间全部被占用的情况，此时也不能实现插入。

- 若前面检查通过则数据元素依次向后移动一个位置；为避免覆盖原数据，应从最后一个依次向前移动。

- 新数据元素放到恰当位置

- 表长加1



```c
Status List_Insert(SqListPtr *L, int pos ,ElemType elem)
{
    Status s = range_error;
    // 查看下标是否越界
    if((pos - 1) >= 0 && (pos - 1) <= L->length){
        // 查看表是否为空，是否容量未满
        if(L && L->length < L-> list_size){
            // 往前移动元素，空出位置来容纳新元素
            for(int i = L->length - 1; i >= pos - 1; --i)
            {
            	L->elem[i+1] = L->elem[i];
            }
           	// 插入新元素
            L->elem[pos - 1] = elem;
            L->length++；
            S = success;
        } else {
            // 表为空或者容量已满，不能插入
            s = fail;
        }
    }
    
    return s;
}
```



### 2.3.6、线性表的删除

> 删除元素操作

步骤

- 检查删除操作是否合法；

- 若检查通过，数据元素依次向前移动一个位置；

- 表长减1；

```c
Status List_Delete(SqListPtr *L, int pos)
{
    Status s = range_error;
    // 确保下标不越界
    if((pos - 1) >= 0 && (pos - 1) <= L->length){
        // 确保表不为空
        if(L && L->length > 0){
            // 依次往前移动元素，覆盖被删除的值
            for(int i = L->pos ; i < L->length; ++i)
            {
            	L->elem[i - 1] = L->elem[i];
            }
            
            L->length--；
            S = success;
            
        } else {
   	 		S = fail;
    	}
    }
    return s;
}
```



> 注释：POS位置，elem数据
>
> 顺序存储结构可以存储线性表的数据，支撑线性表的基本和复杂操作的实现





## 2.4、线性表的链式存储结构

- 链式存储结构的概念
- 关于存储结构的练习
- 单链表的定义
- 单链表的查找操作
- 单链表的其他操作
- 建立单链表的操作
- 特殊形式的链表





### 2.4.1、链式存储结构的概念

> 单链表的概述

**用一组地址任意的存储单元存放线性表中的数据元素**
*结点 = 数据域（数据元素） + 指针域（指示后继元素存储位置）*
**以“结点的序列”表示线性表 —— 称作链表**



> 结构

![链式存储结构的概念](图片/链式存储结构的概念.png)

$→ head →a1 → a2 →... ...→an $



<u>以线性表中第一个数据元素a1的存储地址作为线性表的地址，称作**线性表的头指针**。</u>

有时为了操作方便，在第一个结点之前虚加一个“**头结点**”，并用链表的头指针指向头结点，称为*带头结点的单链表*。



> 带头节点和不带头结点的链表的区别

1. 不带头节点

- 链表指针存放链表第一个数据元素结点的地址

- 空链表时该指针域为NULL

2. 带头结点的单链表

- 一个专门的结点，称为头结点

- 该头结点永远存在

- 该头结点指针域存储第一个数据元素结点的地址

- L.next = NULL



### 2.4.2、关于存储结构的练习

> 练习题

- [x] 1、线性表可以采用顺序存储结构存储数据，也可以采用链式存储结构存储数据？正确

- [x] 2、访问线性表的第i个元素，顺序存储结构通过地址计算公式可以一步到位访问到，采用单链表需要从头指针开始依次访问单链表的每一个元素，最坏时间复杂度为O（n）正确

- [x] 3、链式存储结构不止单链表一种链表形式来存储线性表的元素和关系。正确
- [ ] 4、头指针为L，则单链表为空的表示方法为L = NULL? 错误
- [x] 5、已知指针p指向单链表L的第i个结点，则访问第i个数据和第i + 1个数据方法分别是p->data 和 p->next->data 正确



### 2.4.3、单链表的定义

> 类型定义

```c
typedef struct Node
{
    ElemType data;
    Struct Node *next;
} Node, *Ptr;

typedef Ptr *SqListPtr；
```

> 变量定义和使用

```c
Node n1,n2;
/* 定义一个指向结点的指针变量p，并存放n1的地址（指针）*/
N1.next = &n2;	// 结点n1的指针域存放结点n2的地址
Ptr L = p;		// 定义一个单链表
N2.next = NULL;
```



### 2.4.4、单链表的查找操作

> 查找——按位置查找

问题：在给定的带头结点的单链表L中，查找指定位置的数据元素，如果存在，则返回success，同时取回相应结点的数据

方法：链表的操作只能从头指针出发，顺着链域next逐个结点比较，直到搜索到指定的位置的结点为止

在单链表中获取第POS个元素

`List_Retrieve(SqListPtr L, int pos, ElemType *elem)`

$L  → 21| → 18| → 30| →56|$

`pos = 3;`



伪代码

```c
Status List_Retrieve(SqListPtr L, int pos, ElemType *elem)
{
    置初值部分：需要p指针指向线性表第一个元素；整数i = 1表示访问第一个元素
    While（循环控制条件）// 需要对POS的合法性进行检查
    {
        循环体
    }
    出循环后找到的判定的条件及相应处理 // i = pos 且P指针指向结点不空
}
```

C语言具体实现

```c
Status List_Retrieve(SqListPtr L, int pos, ElemType *elem)
{	//初始化：设置状态变量status，设置移动指针p、计数变量i
    Status s = range_error;
    
    Ptr p = (*L)->next; /* 带头结点，移动p指向第一个元素结点 */
    int i = 1; 			// 计数器
    while(p && i < pos)/* p指向的结点存在，且未到达指定位置 */
    {	// 条件一防止POS > 表长；条件2控制第POS个，防止 POS < 1
        i++；
        P = p->next;
    }
    if(p && i == pos){// 找到指定位置，且该结点存在
        *elem = p->data;
        S = success;
    }
    return s;
}
```

其他实现

![单链表按位置查找元素](图片/单链表按位置查找元素.png)



> 查找——按值查找

算法思想描述：

1. 初始化：p指针指向线性表第一个结点；位置i = 1；操作状态s为错误

2. 只要线性表不空，循环做下面的操作

3. 如果待查找数据 == 当前结点数据，则退出循环

4. 否则p指针指向下一个结点；位置计算器i增1

5. 循环外面判断p != NULL，则找到数据，将位置i赋值给pos参数；修改操作状态s为成功；

6. 返回操作状态s



C语言参考代码

```c
Status List_locate(SqListPtr L, ElemType elem, int *pos)
{	//
    Status s = range_error;
    Ptr p = (*L)->next; /* */
    int i = 1; //计数器
    while(p && p->data != elem)/* */
    {	
        // if(p->elem == elem) break;
        i++；
        P = p->next;
    }
    if(p){//
        *pos = i;
        s =success;
    }
    return s;
}
```



### 2.4.5、单链表的其他操作

> 插入操作

步骤：

1. 找到$a i -1$的位置

2. 构造一个数据域为elem的新结点

3. 将其挂在单链表表上

![单链表的插入操作](图片/单链表的插入操作.png)



C语言实现

```c
Status List_Insert(SqListPtr L, int pos, ElemType elem,)
{	// 移动指针定位，修改指针内容，不移动数据元素
    Status status;
    Ptr p,s;
	// 查找其位置，并插入
    status = List_Retrival (L, pos - 1, &p);
    If(status == success){
        s = (LinkedPtr) malloc(sizeof(Node));
        if(s){
            s->elem = elem;
            s>next = p->next;
            p->next = s;
            status = success;
        } else {
        	status =fatal;
        }

    } else {
    	status = range_error;
    }
    return status;
}
```



> 删除操作

单链表上的删除操作

删除单链表第i个元素

List_Remove(SqListPtr L, int pos )

 ![单链表的删除操作](图片/单链表的删除操作.png)

步骤：

1. 首先求得第i - 1个结点的指针p

2. 修改i - 1个结点的后继域为第i + 1个结点的地址

3. 在释放第pos个结点所占的存储空间



代码实现

```c
Status List_delete(SqListPtr L, int pos)
{	//移动指针定位	修改指针内容	不移动数据元素
    Status status = fail;
    Ptr s, p;

    Status = List_Retrival(L, pos - 1, &p);
    if(status == success){
        s = p->next;
        p->next = s->next;
        free(s);
        s = NULL;
        status = success;
    }

    return status;
}
```



### 2.4.6、建立单链表的操作

$L  =  （a1,  a2,  a3,......,an）$

> 创建单链表

方法：首先创建一个空的单链表，然后依次建立各元素结点，并逐个插入链表

操作步骤：

1. 建立一个“空表”

2. 输入数据元素$an$，建立结点并插入到单链表

3. 输入数据源$a n - 1$，建立结点并插入到单链表

4. 以此类推，直至输入$a1$为止。



C语言实现

```c
Status List_Create(SqListPtr L, ElemType data[ ], int len)
{	//
    Status s;
    Ptr p;
    s = List_Init(L);

    if(s == success ){
        for(int i = len - 1; i >= 0; --i)
        {
            p = (Ptr)malloc(sizeof(Node));
            if(p){
                p->elem = data[i];
                p->next = (*L)->next;
                (*L)->next = p;
            }else{
                s = fail;
                break;
            }
        }
    }

    return s;
}
```



### 2.4.7、特殊形式的链表

> 下面是几种特殊形式的链表

1. 循环单链表

 ![循环单链表](图片/循环单链表.png)

2. 带尾指针的循环单链表

应用场景一：将两个循环单链表合并 

应用情景二：经常需要在最后一个元素后面添加新元素和在第一个元素前面插入新元素

![带尾指针的循环单链表](图片/带尾指针的循环单链表.png)

3. 双向链表

![双向链表](图片/双向链表.png)

> 双向链表的操作特点：

“查询”和单链表相同。

![双向链表的空表和非空表](图片/双向链表的空表和非空表.png)

“插入”和“删除”时需要同时修改前后两个方向上的指针。

> 双向链表插入操作

![双向链表插入操作](图片/双向链表插入操作.png)

> 双向链表删除操作

![双向链表删除操作](图片/双向链表删除操作.png)

4. 静态链表

某些语言中不提供指针，如Java和Visual BASIC等，只能通过其他方式来模拟指针

采用数组模拟链表的指针，用以表示数据元素后继所存放位置

数据元素的存储空间像顺序表一样是事先静态分配的

数据元素之间的关系像链表一样是显示的

![静态链表](图片/静态链表.png)





## 2.5、栈

- 操作受限的线性表——栈
- 栈的定义
- 栈的抽象数据类型
- 栈的基本操作
- 栈的顺序存储
- 顺序栈的出入栈操作实现
- 栈的链序存储
- 链栈的出入栈操作实现
- 栈的简单应用



### 2.5.1、操作受限的线性表 —— 栈

> 回顾

**线性表：n个相同元素的有限序列**

$DS = (D,L,O,S);$

**线性表的逻辑结构L：1对1（前驱、后继）**

**线性表的基本操作O：创建、查找元素、插入、删除等**

**线性表的存储结构S: 顺序、链式（单链表、双向链表、循环、双向循环）**

![数据结构关联图](图片/数据结构关联图.png)



**栈是一种先进后出(FILO：First In Last Out)的数据结构。**

<u>**栈是限定插入和删除只能在表的“端点”进行的线性表。栈是特殊的线性表，是插入、删除操作受限的线性表。**</u>

<u>**顺序栈的栈顶是数组尾部，链表栈的栈顶是头部**</u>



### 2.5.2、栈的定义

> 定义

栈是限定在表的同一段进行插入或删除操作的线性表。进行插入或删除操作的一端称为栈顶，另一端称为栈底。没有数据元素的栈称为空栈。插入数据元素的操作称为入栈，删除元素的操作称为出栈。

![栈的定义](图片/栈的定义.png)

> 栈的运算特性：

后进先出（Lass In First Out--LIFO）或先进先出（First In Last Out--FILO）





### 2.5.3、栈的抽象数据类型定义

![栈的抽象数据类型定义](图片/栈的抽象数据类型定义.png)

```c
ADT Stack{
    数据对象：
    D = {a i | a i ∈ ElemSet, i = 1,2,...,n, n≥0}
    数据关系：
    R1 = {＜a i-1, a i ＞| a i-1, a i∈D, i =2,...,n}
    约定an端为栈顶，a1端为栈底
}
```



### 2.5.4、栈的的基本操作

> 基本操作

```c
// 初始化栈
Stack_Init(StackPtr s);
// 销毁栈
Stack_Destroy(StackPtr s);
// 获取栈的长度
Length_Stack(StackPtr s);
// 判断栈是否为空
Stack_Empty(StackPtr s);
// 清空栈
Stack_Clear(StackPtr s);
// 获取栈顶元素
Stack_Top(StackPtr s, StackEntry *item);
// 入栈操作
Stack_Push(StackPtr s, StackEntry item);
// 出栈操作
Stack_Pop(StackPtr s, StackEntry *item);
```



测试栈的基本操作

![测试栈的基本操作](图片/测试栈的基本操作.png)



> 论述题

1. 采用顺序存储结构或者链式存储结构实现的线性表为基础，
   编程实现栈的基本操作?
2. 如果采用顺序存储结构的线性表，栈顶在哪里？
   如果采用带头结点的单链表，栈顶又在哪里？为什么
3. 如果不采用线性表的基本操作为基础，我们自己来完整的编程实现栈的基本操作，采用哪种存储结构更合适？
   需要做哪些工作？
   什么时候需要我们这样编程？



### 2.5.5、栈的顺序存储

> 类型定义

```c
typedef struct stack 
{
    // 就是线性表顺序存储结构的length
    int top; 	
    // 动态分类空间大小为stack_size
    StackEntry *elem;	
    int stack_size;
} Stack, *StackPtr;
/*
	约定top用于存放栈顶元素的位置
	top = -1 表示空栈
	top = stack_size - 1 表示栈满
*/
```

![顺序存储结构的栈](图片/顺序存储结构的栈.png)

- 入栈时top指针 + 1；出栈时top指针 - 1

溢出判定

1. 顺序栈的数据元素空间大小是预先分配的
2. 当空间全部占满再入栈产生的溢出称为“上溢”
3. 当栈为空时再出栈也将产生的溢出称为“下溢”



### 2.5.6、顺序栈的出入栈操作实现

> 入栈操作

````c
// 入栈操作
Status Stack_Push(StackPtr s,StackEntry item)
{
	Status outcome = success;
	if(Stack_Full(s)){
		ontcome = overflow;		/* 栈满则上溢 */
	}else{
		s->top++;
		s->entry[s->top] = item;/* 数据元素放入top位置 */
	}
	return outcome; 
} 
````

> 出栈操作

```c
Status Stack_Pop(StackPtr s, StackEntry *item)
{
	Status outcome = success;
	if(Stack_Empty(s)){
		outcome = underflow;	/* 栈空则下溢 */
	}else{
		/* 将top所指数据元素放入item，top再减一 */ 
        *item = s->entry[s->top--];	
	}
	return outcome;
} 
```

> 获取栈顶元素

```c
Status Stack_Top(StackPtr s, StackEntry *item)
{
	Status outcome = success;
	if(Stack_Empty(s)){
		outcome = underflow;	/* 栈空则下溢 */
	}else{
		/* 取出数据，top指针不变 */ 
        *item = s->entry[s->top];	
	}
	return outcome;
} 
```

如果有多个顺序栈可以空间共享

![多个顺序栈空间共享](图片/多个顺序栈空间共享.png)





### 2.5.7、栈的链式存储

（1）**单链表**

（2）**循环链表**

（3）**双向链表**

栈底：链表尾部

栈顶：链表头部

 

> 存储结构设计

采用单链表的节点结构：

将单链表的首端作为栈顶：



> 类型定义

```c
typedef struct node /* 结点类型定义 */
{
    StackEntry entry;
    struct node* next;
} StackNode, *StackNodePtr;

typedef struct stack /* 链栈类型定义 */
{
	StackNodePtr top;/* 指向栈顶的指针 */
} Stack, *StackPtr;
```



### 2.5.8、链栈的出入栈操作实现

> 入栈操作

```c
Status Stack_Push(StackPtr * s, StackEntry item)
{
	Status outcome = success;
	StackNodePtr * np = MakeNode(item);
	/*申请结点空间，并装填节点域*/
	if(np == NULL){
		outcome = overflow;/*无法分配储存空间，相当于栈满上溢*/ 
	} else {
		np->next = s->top;/*所申请的节点插入在表头*/
		s->top = np; 
	}
	return outcome;
}
```



> 出栈操作

```c
Status Stack_Pop(StackPtr *s, StackEntry *item)
{
	Status outcome = success;
	if(Stack_Empty(s)){
		outcome = underflow;		/* 栈空则下溢 */
	} else {
		StackNodePtr *np = s->top;	/* 删除栈顶元素 */
		s->top = np->next;
		*item = np->entry;
		free(np);
	}
	return outcome;
}
```



### 2.5.9、栈的简单应用

> 练习题：

1、已知a,b,c入栈，则不可能的出栈顺序是（c）
A.abc	B.cba	C.cab	D.acb

2、如果要讲输入的线性表倒序输出，采用栈怎么实现这个功能？
3、如果要讲输入的线性表按照原输入顺序输出，采用栈怎么实现这个功	能？

括号配对问题
输入一个四则运算表达式，如何判断括号是否配对？括号包括(){}[]
（1）依次读入四则运算表达式
（2）如果是左括号入栈
（3）如果是右括号，则与栈顶的左括号进行匹配：
①类型相同，匹配，转第一步继续
②类型不匹配，输出错误提示，结束程序。

> 作业

编程实现括号配对问题。要求输入四则运算表达式，判断括号是否配对，如果全部配对，输出（“所有括号都配对”）；否则输出（“括号不配对，不能进行计算”）。



> 讨论

输入四则运算表达式，如何计算输出结果？
已知迷宫地图，如何寻找入口到出口的通路？
如何用算法生成具有1个入口，1个出口，且入口到出口有通路的迷宫地图？地图长宽根据输入确定。







## 2.6、队列

- 队列的定义

- 队列的抽象数据类型
- 队列的基本操作
- 队列的顺序存储
- 循环顺序队列
- 队列的链式存储
- 链式队列的出入队操作



### 2.6.1、队列的定义

> 概述

**定义：队列是限定只能在表一端进行插入，在表的另一端进行删除的线性表**

- 队尾（real）——允许插入的一端
- 队头（front）——允许删除的一端
- 队列特点：先进先出（FIFO: First In First Out）





### 2.6.2、队列的抽象数据类型

![队列的抽象数据类型](图片/队列的抽象数据类型.png)

```c
ADT Queue{
    数据对象：
    D = {ai| ai∈ElemSet, i = 1,2,....,n, n≥0}
    数据关系：
    R1 = {＜a i-1, ai ＞ | a i-1 ai∈D, i = 2,...,n}
    约定其中a1端为队头，an端为队尾
}ADT Queue
```



### 2.6.3、队列的基本操作

```c
基本操作:
初始化：Status Queue_Init(QueuePtr q)
销毁：	void Queue_Destory(QueuePtr q)
清空：	void Queue_Clear(QueuePtr q)
判空： void Queue_Empty(QueuePtr q)
判满：	void Queue_Full(QueuePtr q)
入队：Status Queue_Append(QueuePtr q, QueueEntry item);
出队：Status Queue_Server(QueuePtr q, QueueEntry *item);
```



> 练习题——队列的编程实现

采用线性表的基本操作为基础，实现队列的功能。其中入队操作，采用线性表的基本操作的插入函数，插入位置每次都在尾部；出队操作，先采用线性表的定位查找，将第1个位置的元素找到，然后采用线性表的删除操作，删除第1个位置的元素。



1、采用线性表的基本操作为基础，实现队列的功能。
2、自己定义并实现队列的操作，而不用借助线性表的基本操作。



顺序存储：出队移动大量数据
链式存储：入队定位时间较长



### 2.6.5、队列的顺序存储

```c
类型定义
#define MAXQUEUE 10

typedef struct queue
{
	int front,rear;/*队头和队尾指针，指示队头和队尾数据元素的位置*/
	QueueEntry entry[MAXQUEUE];	/*数据元素存储空间*/

}Queue,*QueuePtr;	/*定义为新的数据类型*/

// 问题：初始化队列为空，font和rear的值是多少呢？、
// 实际上初始化font=rear=0或者font=rear=-1都是可以的
```

- 约定：队头指针指向队头元素前面一个位置，队尾指针指向队尾元素位置

![队列的顺序存储](图片/队列的顺序存储.png)

- 如何解决“假溢出”问题？
- 视为“循环顺序队列”
  实现方法： 

- front = (front + 1) % MAXQUEUE
- rear = (real + 1) % MAXQUEUE



### 2.6.6、循环顺序队列

> 循环顺序队列——如何判断空还是满?

![循环队列产生的问题](图片/循环队列产生的问题.png)



方法一：	用一个计数变量来记载队列中的元素个数。

- 初始化队列时 C = 0;
- 当入队时，计数器加1；

- 当出队时，计数器减1；

- 当计数器 = MAXQSIZE时，队满

- 当计数器 = 0时，队空



方法二：	设置一个flag标志位用来区分队列是空还是满

1. 初始化队列： sq-> front = sq -> rear,标志位为false

2. 入队后，使sq-> front = sq->rear, 则标志位为true

3. 出队后，将标志位置为false

4. 当sq-> front = sq -> rear, 且标志位为true时，队满。

5. 当sq-> front = sq -> rear, 但标志位为false时，队空

6. 其他情况非空非满

 

方法三： 牺牲一个元素空间，来区别队空或队满。

- 入队前，先判断sq->rear+1是否等于sq-> front, 若是则为队满。

- 而当sq ->front == sq-> rear时，为队空。

- 前例：当E入队后，就认为队已满，而当F要再入队时就拒绝入队



### 2.6.7、队列的链式存储

> 哪种链表适合队列？

队列链表结构分析

- 主要操作：链表尾部插入，链表头部删除

- 需要有头结点和尾节点的链表

![队列的链式存储](图片/队列的链式存储.png)



> 类型定义

```c
typedef int QueueEntry;

typedef struct _node{			/* 链式队列的结点结构 */
	QueueEntry Entry;			/* 队列的数据元素类型 */
	struct _node * next;		/* 指向后继结点的指针 */
} QueueNode,*QueueNodePtr;

typedef QueueNode QueueNodePtr;	// 队列类型
 
typedef struct _queue{			/* 链式队列 */
	QueueNode * front;			/* 队头指针 */
	QueueNode * rear;			/* 队尾指针 */
} Queue,*QueuePtr; 

typedef Queue QueuePtr;			// 队列类型
```



### 2.6.8、链式队列的出入队操作

![链式队列出队入队操作](图片/链式队列出队入队操作.png)



> 讨论

银行排队模拟系统：设计一个最简单的排队系统模拟器，即只有一个服务台的排队系统，希望通过这个模拟器得到顾客的平均排队时间。
①讨论采用模拟系统而不是真实系统的原因
②讨论模拟系统的主要操作
③写出单排队系统的算法步骤，并编程实现，模拟测试顾客的平均排队时间



# 第三章、查找

- 查找的基本概念
- 顺序查找
- 折半查找
- 索引查找
- 哈希查找





## 3.1、查找的基本概念

- 查找表
- 查找表的基本操作
- 查找表的分类
- 平均查找长度
- 常见查找算法







### 3.1.1、查找表

**查找表是由同类型的数据元素（或记录）构成的集合。**



### 3.1.2、查找表的基本操作

1. 查询某个数据元素是否在查找表中；
2. 检索某个数据元素的各种属性；
3. 在查找表当中插入一个数据元素;
4. 从查找表中删去某个数据元素。





### 3.1.3、查找表的分类

> 静态查找表（Static Search Table）

仅做查询和检索操作的查找表



> 动态查找表（Dynamic Search Table）

“查询”结果“不在查找表中”—>数据元素插入到查找表中；
“查询”结果为“在查找表中”的数据元素->删除。



查找过程中，往往是依据数据元素的某个数据项进行查找，这个数据项通常是数据的关键字。
关键字：是数据元素中某个数据项的值，用以标识一个数据元素。
若关键字能标识唯一的一个数据元素，则称为主关键字。
若关键字能标识若干个数据元素，则称为次关键字。
张三 2016010002 男 成都 1.75





### 3.1.4、平均查找长度ASL

$ASL = P1C1 + P2P2 +...+PnCn$

$Pi$——查找第$i$个元素的概率

$Ci$——查找第$i$个元素需要的比较次数

![平均查找长度ASL](图片/平均查找长度ASL.png)



### 3.1.5、常见的查找算法

主要有顺序查找、二分查找、索引查找和哈希查找这几种。



## 3.2、顺序查找

- 顺序查找基本思想(Sequence Search)
- 代码实现
- 顺序查找性能分析



### 3.2.1、顺序查找基本思想(Sequence Search)

> 概念

从表中指定位置（一般为最后一个，第0个位置设为岗哨）的记录开始，沿某个方向将记录的关键字与给定值相比较，若某个记录的关键字和给定值相等，则查找成功；

反之，若找完整个顺序表，都没有与给定关键字值相等的记录，则此顺序表中没有满足查找条件的记录，查找失败。



### 3.2.2、代码实现

> C语言示例代码

```c
int SequenceSearch(DataType R[], KeyType key)
{
	int i;
	R[0] = key;	i = n;	
	while (R[i] != key) 
	{
		i--;
	}
	return i;
}
```

例题，查找key为60的记录

![顺序查找例题](图片/顺序查找例题.png)



### 3.2.3、顺序查找性能分析

> 空间复杂度： 

O(1)

> 时间复杂度：

查找算法的基本运算时给定值与顺序表中记录关键字值的比较

最好情况：O(1)
最坏情况：O(n)
平均情况：O(n)



> 平均查找长度：

![顺序查找性能分析](图片/顺序查找性能分析.png)



- 等概率情况
  $Pi = 1 / n$
  $ASL = 1 / N   （n - i + 1） = (n + 1)  / 2$
- 不等概率
  - 每个元素的查找概率已知
  - 每个元素的查找概率未知



## 3.3、折半查找

- 折半查找基本思想（BinarySearch）
- 代码实现









### 3.3.1、折半查找基本思想（BinarySearch）

有序表：如果顺序表中的记录按关键字值有序



> 查找过程：

将待查关键字与有序表中间位置的记录进行比较，若相等，查找成功。若小于，则只可能在有序表的前半部分，若大于则只可能在有序表的后半部分，因此，经过一次比较，就将查找范围缩小一半，这样一直进行下去直到找到所需记录或记录不在查找表中。



### 3.3.2、代码实现

> C语言实现

```c
int BinarySearch(DataType SL[], KeyType key, int n)
/*在长度为n的有序表SL中查找其关键字等于key的记录*/
/*查找成功返回其在有序表中的位置，查找失败返回0*/
{
	int low = 1;
	int hight = n;
	
	while(low <= hight)
	{
		DataType mid = (low + hight) / 2;
	
		} else if(key > SL[mid]){
			low = mid + 1;
		} else if(key < SL[mid]){
			hight = mid - 1;
		} else return mid;	
	}
	
	return 0;
}
```

例题，查找key为64的记录

![折半查找例题](图片/折半查找例题.png)



### 3.3.3、折半查找的性能分析

以深度为h的满二叉树为例

![折半查找性能分析](图片/折半查找性能分析.png)

即：n = 2^h - 1并且查找概率相等，则

![折半查找的ASL](图片/折半查找的ASL.png)



> 折半查找特点：

折半查找的查找效率高

平均查找性能和最坏性能相当接近

折半查找要求查找表为有序表

并且，折半查找只适用于顺序存储结构。



## 3.4、索引查找

- 索引查找基本思想（IndexSearch）
- 索引表的构建
- 索引表的查找
- 索引表的顺序性能分析
- 三种查找算法比较





### 3.4.1、索引查找基本思想（IndexSearch）

> 索引使用方法：

先分析数据规律，建立索引

再根据索引进行快速定位

在定位的地方进行细致搜索

![索引查找](图片/索引查找.png)

先分块，块间有序，就可以做到快速定位到块



### 3.4.2、索引表的构建

1. 分块：

第$R^k$中所有关键字<$R^(k+1)$块中所有关键字，$(k = 1,2,3,4,5,...L-1)$

2) 建立索引项：

关键字项：记载该块中最大关键字值；

指针项：记载该块第一个记录在表中位置。

![索引表的构建](图片/索引表的构建.png)





### 3.4.3、索引表的查找

索引表的查找——>>>查找表的查找(顺序查找 or 折半查找)



> 例子：

![索引表的例题](图片/索引表的例题.png)



> 索引表的顺序查找算法思想描述：

首先根据带查找关键字在索引表当中定位块。定位的方法是：只要key>索引块i的最大关键项，则i++，定位下一个索引项；直到定位到索引快，或者把索引项都定位完也没有比key关键字大的索引项。

如果定位到块，则在块内部进行顺序查找

> 代码实现

````c
typedef struct IndexType{
	KeyType key;
	int Link;
}IndexType; 

int IndexSequelSearch(IndexType Is[],DataType s[], int m, KeyType key)
{
	/* 索引表为Is[0]-Is[m-1],顺序表为s */
	int i = 0;
	while(i < m && key > Is[i].key) i++;	/* 块内查找*/
	if(i == m)return -1;
	else{
		int j = Is[i].Link;
		while(key != s[j].key && j<Is[i+1].Link)j++;
		if(key == s[j].key)return j;	/* 查找成功 */
		else return -1;					/* 查找失败 */
	}
} 
````



### 3.4.4、索引表的顺序查找性能分析

> 索引顺序查找的ASL?

ASL=ASL(索引表)+ASL(块内)



索引表的顺序查找性能分析

![索引表的顺序查找性能分析](图片/索引表的顺序查找性能分析.png)

其中，n为表长，均匀分为b块，每块含有s个记录



### 3.4.5、三种查找算法比较

![三种查找方法比较](图片/三种查找方法比较.png)





## 3.5、哈希查找

- 哈希函数
- 哈希表
- 常见的哈希函数构造方法
- 字符串的哈希查找
- 哈希冲突的解决方案
- 开放地址法
- 再哈希法
- 链地址法
- 建立公共溢出区



### 3.5.1、哈希函数

顺序查找：O(n),平均约比较500次

二分查找：O(logn),平均约比较10次

有没有更好的查找方法？



> 哈希函数定义

一般情况下，需在关键字与记录在表中的存储位置之间建立一个函数关系，以==H(key)==作为关键字为key的记录在表中的位置，通常称这个函数为==哈希函数==。



> 哈希函数H(key)
> 关键字集合A(m) ----->地址空间D(n)

1) 哈希函数是一个映象，即：**将关键字的集合映射到某个地址集合上**，它的设置很灵活，只要这个地址集合的大小不超过允许范围即可;

2. 由于哈希函数是一个压缩映象，因此，在一般情况下，很容易产生“冲突”现象，即：`key1 ≠ key2 ` 而 `h(key) == h(key2)`

3. 很难找到一个不产生冲突的哈希函数。一般情况下，只能选择恰当的哈希函数，使冲突尽可能少地产生。



因此，哈希查找需要做两方面事情：选择一个“好”得哈希函数；提供一种“处理冲突”的方法；



### 3.5.2、哈希表

> 概述

根据设定的==哈希函数H(key)==和提供的处理冲突的方法，将一组关键字映象到一个地址连续的空间上，并以关键字在地址空间中的“象”作为相应记录在表中的存储位置，如此构造所得的查找表称为==哈希表==。

地址空间存储的数据集合称为**哈希表**

![哈希表](图片/哈希表.png)



### 3.5.3、常见的哈希函数构造方法

一般来说，一个好的哈希函数应该满足下列两个条件

（1）计算简单

（2）冲突少



> 常见的哈希函数构造方法



1. 直接哈希函数

取关键字本身或关键字的某个线性函数值作为哈希地址

![直接哈希函数](图片/直接哈希函数.png)





2. 数学分析法

设n个d位数的关键字，由r个不同的符号组成，此r个符号在关键字各位出现的频率不一定相同，可能在某些位置上均匀分布，即每个符号出现的的次数都接近与n/r次，二在另一些位上分布不均匀。则选择其中分布均匀的s位作为哈希地址，即哈希函数为 ==H(key) = “key中数字均匀分布的s位”==

![数学分析法](图片/数学分析法.png)

即H(key)=key，key中数字均匀分布的s位



3. 平方取中法

取关键字平方后中间几位作为哈希地址，即哈希函数为

==H(key) = “key²的中间几位”==。其中，所取得位数由哈希表的大小决定

思想：以关键字的平方值的中间几位作为存储地址。求“关键字的平方值”的目的是“扩大差别”和“贡献均衡”。

![平方取中法](图片/平方取中法.png)

即：关键字的各位都在平方值的中间几位有所贡献，hash值中应该有各位影子



题目：请为BASIC源程序中的标识符建立一个哈希表。假设BASIC语言中允许的标识符为一个字母，或一个字母加一个汉字数字。标识符在计算机中的八进制为它的关键字。



4. 折叠法

关键字位数较长时，可将关键字分割成位数相等的几部分（最后一部分位数可以不同），取这几部分的叠加和（舍去高位的进位）作为哈希地址。位数由存储地址的位数确定。叠加时有两种方法：移位叠加法：即将每部分的最后一位对齐，然后相加；

![折叠法](图片/折叠法.png)

移位叠加法，即将每部分的最后一位对齐，然后相加

边界叠加法：即把关键字看作一纸条，从一端向另一端沿着边界逐次折叠，然后对齐相加。



5. 除留余数法

取关键字被某个不大于哈希表长度m的数p除后的余数作为哈希地址，即：

$H（key）= key MOD p(p≤m)$

![除留取余法](图片/除留取余法.png)

6. 随机数法

选择一个随机函数，取关键字的随机函数值作为哈希地址

$H（key）= random（key）$![随机数法](图片/随机数法.png)



### 3.5.4、哈希函数考虑因素

> 考虑因素：

计算简单

冲突少

哈希表的长度

哈希表的大小

记录的查找频率





### 3.5.5、字符串的哈希查找

**properties of *f*:**
① $f(x)$必须能够计算任意关键字且冲突最少
② $f(x)$应该**均匀分布**，比如对任意x和i，有如下概率$probability(f(x) = i) = 1/b$.这种函数叫（均匀分布哈希函数）
Uniform Hash Function

`f(x) = x % 0 TableSize;	/* if x is an integer */`

![字符串的哈希查找](图片/字符串的哈希查找.png)



> 代码实现

````c
Index Hash3(const char * x, int TableSize)
{
	unsigned int HashVal = 0;
	while(*x != '\0')						/* 1 */
	{										
		HashVal = (HashVal<<5) + *x++;		/* 2 */
	}
	return HashVal % TableSize;				/* 3 */
}
advice：
carefully select some characters from x.
if x is too long(e.g.strerr address), the early
characters will be left-shifted out of place.
````



### 3.5.6、哈希冲突的解决方案

> 冲突

是指由关键字得到的hash地址上已有其他记录。

好的哈希函数可以减少冲突，但无法完全避免冲突



> 冲突处理

为出现哈希地址冲突的关键字寻找下一个哈希地址



常见的冲突处理方法有

- 开发地址法
- 再哈希法
- 链地址法
- 建立公共溢出区





#### 3.5.6.1、开放地址法

> 为产生冲突的地址H（key）求得一个地址序列。

$H0,H1,H2,H3...Hs 1≤s≤m-1$

其中：$H0 = H(key)$

$Hi = (H(key)+di) MOD m$

i = 1,2,...,s

 ![开放地址法01](图片/开放地址法01.png)

Hi为第i次冲突的地址，i = 1,2,...,s

H(key)为hash函数值

m为hash表表长

di为增量序列

![开放地址法02](图片/开放地址法02.png)



例题如下

> 采用线性探测再散列

![采用线性探测再散列](图片/采用线性探测再散列.png)



> 采用二次探测再散列

![采用二次探测在散列](图片/采用二次探测在散列.png)



> 采用随机数探测再散列

![采用随机数探测再散列](图片/采用随机数探测再散列.png)



#### 3.5.6.2、再哈希法

> 概念

![再哈希法](图片/再哈希法.png)



#### 3.5.6.3、链地址法

> 概念

![链地址法](图片/链地址法.png)



#### 3.5.6.4、建立公共溢出区

> 概念

![建立公共溢出区](图片/建立公共溢出区.png)





### 3.5.7、哈希查找过程

> 哈希表查找

<u>在哈希表上查找的过程和哈希造表的构造过程基本一致</u>

1) 给定K值，根据构造表时所有的哈希函数求哈希地址j

2) 若此关键无记录，则查找失败

否则比较关键字，若和给定的关键字相等则成功

否则根据构造表时设定的冲突处理的方法计算“下一地址”，重复第二步



> 哈希表查找算法

```c++
Status SearHash(HashTable H, KeyType key, int &p, int &c)
{
   /* 在开放定址哈希表H中查找关键字为key的数据 */
   /* 用C记录发生冲突的次数，初值为0 			*/
    p = Hash(k); /* 求哈希地址 */
	// 说明该位置填有数据且与搜查关键字不同
    while(H.data[p].key != NULL && H.data[p].key != key)
    {
        collision(p, ++c); /* 求下一探查地址p */
    }
    
    if(H.data[p].key == key) {
        /* 查找成功, p返回待查找数据元素位置 */
        return SUCCESS;	
    } else {
		/* 查找不成功, p返回插入位置 */
        return UNSUCCESS;
    }
    
}
```

> 哈希表插入算法

```c++
Status InsertHash(HashTable &H, DataType e)
{
    /* 查找不成功时在H中插入数据元素e，并返回SUCCESS */
    /* 若哈希冲突过大，则重建哈希表 */
    int c = 0;
    if(SearchHash(H, e.key. p, c)) {
        return UNSUCCESS; /* 数据已存在哈希表中 */
    } else if(c < hashsize[H.sizeindex] / 2) {
        H.data[p] = e;
        ++ H.count;	/* 次数c还为达到上限，插入e */
        return SUCCESS;
    } else {
    	/* 重建哈希表 */
        RecreatHashTable(H);
    }
}
```



哈希表查找与插入算法举例

![哈希表查找与插入算法举例](图片/哈希表查找与插入算法举例.png)



### 3.5.8、哈希查找性能分析

> 性能分析

例如：关键字序列{19, 23, 01, 68, 20, 84, 27, 55, 11, 10, 79}

`H(key) = key % 12`

使用==线性探测处理冲突==时，ASL = 1/12(1 * 6 + 2 + 3 * 3 + 4 + 9) = 2.5

使用==链地址法处理冲突==时，ASL = 1/12(1 * 6 + 2 *4 + 3 + 4) = 1.75



一般情况下，可以认为选用的哈希函数是*“均匀”*的。则在讨论ASL时，可以不考虑**哈希函数的因素**

哈希表的平均查找长度是装填因子 α 的函数，而不是 $n$ 的函数。

这说明，用哈希表构造查找表时，可以选择一个适当的装填因子 α，使得平均查找长度限定在某个范围内

——这是哈希表所特有的特点



> 总结 —— 映射的哈希函数

关键字范围广  ——>(哈希函数) 存储空间范围小

冲突不可避免，不同解决冲突的策略的ASL不同

查找表大小与解决冲突策略和ASL范围相关



选择哈希函数 ——> 根据冲突策略与ASL计算哈希表大小 ——> 建立查找表





# 第四章、排序

- 排序基本概念
- 插入排序(Insert Sort)
- 选择排序(Select Sort)
- 交换排序(Exchange Sort)
- 基数排序(Radix Sort)
- 外部排序





## 4.1、排序基本概念

- 什么是排序
- 稳定排序和不稳定排序
- 内部排序和外部排序







### 4.1.1、什么是排序

> 排序

将一组数据元素重新排列，使得数据元素序列按某个数据项（关键字）有序。



> 排序依据：依据数据数据元素的关键字

1. 若关键字是主关键字（关键字值不重复），无论采用何种排序方法，排出的结果都是一致的。

2. 若关键字是次关键字（关键字值可以重复），则排出的结果可能不唯一



一般情况下，假设含 $n$ 个记录的序列为${R1, R2, ... , Rn}$，其相应的关键字序列为${K1, K2, ... , Kn}$

这些关键字相互之间可以进行比较

> 即它们存在着这样一个关系

$Kp1 ≤ Kp2 ≤ ... ≤ Kpn$

按此固有关系将上面的式子记录序列重新排列为

${ Rp1, Rp2, ..., Rpn }$

的操作称作==排序==



### 4.1.2、稳定排序和不稳定排序

> 简介

对于任意的数据元素序列，若排序前后所有相同关键字的相对位置都*不变*，则称该排序方法为==稳定的排序方法==

对于任意的数据元素序列，若排序前后所有相同关键字的相对位置*发生了变化*，则称该排序方法为==不稳定的排序方法==



例如：对于关键字序列3, 2, <u>3</u>, 4，若某种排序方法排序后，变为2, <u>3</u>, 3, 4，则该排序方法是不稳定的





### 4.1.3、内部排序和外部排序

> 概念

若整个排序过程==不需要访问外存==便能完成，则称此类排序问题为内部排序；

反之，若参加排序的记录数量很大，<u>整个序列的排序过程**不可能在内存中完成**，则称此类排序问题为外部排序。</u>



内部排序的方法

内部排序的过程是一个**逐步扩大记录的有序序列长度的过程**



## 4.2、插入排序(Insert Sort)

- 插入排序的概念
- 直接插入排序(Straight Insertion Sort)
- 希尔排序(Shell Sort)



### 4.2.1、插入排序的概念

> 基本思想

将无序子序列中的一个或几个记录“插入到”有序子序列中，从而增加有序子序列的长度

![插入排序的基本思想](图片/插入排序的基本思想.png)

实现“一趟插入排序”，可分三步进行

- 插入排序三部曲

1. 在$R[1...i-1]$中查找R[i]的插入位置（定位）

   $R[1...j].key ≤ R[i].key ＜R[j+1...i-1].key$;

2. 将$R[j+1...i-1$]中所有记录均后移一个位置（挤空）

3. 将$R[i]$插入到(复制)到$R[j+1]$的位置（插入）



> 插入排序

- 直接插入排序（基于顺序查找定位）
- 折半插入排序（基于折半查找定位）
- 希尔排序（基于逐趟缩小增量）





### 4.2.2、直接插入排序(Straight Insertion Sort)

> 定义

**直接插入排序（Straight Insertion Sort）的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。**



排序过程：整个排序过程为 n-1 趟插入，即先将序列中第1个记录看成是一个有序子序列，然后从第2个记录开始，逐个进行插入，直到整个序列都有序。

![直接插入排序例题](图片/直接插入排序例题.png)



> 算法描述

```c
/* Ch8_1.c —— 学习直接插入排序 */

// 需要排序的结构
typedef struct _Jd
{
    int key;	/* 排序的关键字 */
    double info;
}JD;

void StraightInsertionSort(JD r[], int n)
{
    // 对长度为n的序列进行排序
    int i, j;
    for(i = 1; i < n; i++) 
    {
        // 临时保存待插入的值
        JD temp = r[i];
        j = i - 1;
        // 比较大小，比关键字大往后移动
        while(j > 0 && temp.key < r[j].key)
        {
            r[j + 1] = r[j];
            j--;
        }
        r[j + 1] = temp;
    }
}
```



> 时间复杂度评价

![直接插入排序算法的性能](图片/直接插入排序算法的性能.png)



分析：用直接插入排序，数据序列越接近有序，比较次数越少



> 思考

简单插入排序的本质？

- 比较和交换
- 序列中<u>逆序的个数</u>，决定交换次数
- 平均逆序数量为$C(n, 2)/2$，所以$T(n) = O(n²)$

简单插入排序复杂度由什么决定？<u>逆序个数</u>

如何改进简单插入排序复杂度？==希尔排序==

- 分组，比如：$C(n, 2)/2 > 2C((n/2),2)/2$
- 3, 2, 1有三组逆序对(3,1)、(3, 2)、(2,1)需要交换3次
- 3,1交换一次后1,2,3就没有逆序对了。



### 4.2.3、希尔排序(Shell Sort)

> 定义

希尔排序（Shell Sort）是D.L.Shell于1959年提出来的一种排序算法，
	在这之前排序算法的时间复杂度都是$O(n^2)$的，希尔排序是突破这个时间复杂度的第一批算法之一。科学家希尔研究
	出了一种排序算法，对直接插入排序改进后可以增加效率。将原本有大量记录数的记录进行分组。分割成若子序列，
	此时每个子序列待排序的记录个数就少了，然后在这些子序列内分别进行一次直接插入排序，
	当整个序列都基本有序（所谓的基本有序，就是小的关键字在前面，大的基本在后面，不大不小的基本在中间）时，
	再对全体记录做一次插入排序。因此，我们需要采取跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，
	这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。

**希尔排序也被称为缩小增量法**



> 排序过程

首先将记录序列分成若干子序列，

然后分别对每个子序列进行直接插入排序

最后等待基本有序，再进行一次直接插入排序

![希尔排序例题](图片/希尔排序例题.png)





> 算法描述

```c
/* Ch8_1.c —— 学习直接插入排序 */

// 需要排序的结构
typedef struct _Jd
{
    int key;	/* 排序的关键字 */
    double info;
}JD;

void StraightInsertionSort(JD r[], int n, int d[], int T)
{
    int i, j, k;
    JD x;
    k = 0;
    // 循环每一趟进行分组，组内进行简单插入排序
    while(k < T) 
    {
    	for(i = d[k] + 1; i <= n; i++) 
        {	// i 为未排序记录的位置
           	// 第零个元素为哨兵
        	x = r[i];
            // j 为本组i前面的记录位置
            j = i - d[k];
            while(j > 0 && x.key < r[j].key) 
            {
                // 组内简单插入排序
                r[j+d[k]] = r[j];
                j = j - d[k];
            }
            r[j + d[k]] = x;
        }    
        k++;
    }
}
```



> 希尔排序的特点

- 子序列的构成不是简单的逐段分割，而是将相隔某个增量的记录组成一个子序列

- 希尔排序可提高排序速度，因为

  分组后n值减少，$n^2$更小，而$T(n) = (n^2)$，所以T(n)总体上看是减小了

  关键字较小的记录跳跃式前移，在进行最后一趟增量为1的插入排序时，序列已经*基本有序*

- 增量序列取法

  无除1以外的公因子

  最后一个增量值必须为1



> 最坏复杂度分析

【定理】使用希尔排序最坏时间复杂度为$O(n^2)$.

![希尔排序时间复杂度分析](图片/希尔排序时间复杂度分析.png)

P增量对**不互质（relatively prime）**。因此比较小的增量可能没有效果



Hibbard's 增量序列

$hk = 2^k - 1$ —— 持续增量没有公共因子

【Theorem】使用Hibbard's增量的最坏时间复杂度为$O(N^(3/2))$

 ![Hibbard's 增量序列](图片/Hibbard's 增量序列.png)



> 时间复杂度评价

![希尔排序算法的性能](图片/希尔排序算法的性能.png)



## 4.3、选择排序(Select Sort)

- 选择排序的概念
- 简单选择排序(Simply Selection Sort)
- 归并排序(Merge Sort)







### 4.3.1、选择排序的概念

> 基本思想

![选择排序过程](图片/选择排序过程.png)

从无序子序列中“选择”关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列长度。

![选择排序例题](图片/选择排序例题.png)





### 4.3.2、简单选择排序(Simply Selection Sort)

> 算法实现

```c
// 需要排序的结构
typedef struct _Jd
{
    int key;	/* 排序的关键字 */
    double info;
}JD;

void smp_selectsort(JD r[], int n)
{
    int i, j, k;
    JD t;
    for(i = 1, i < n; i++)
    {
        k = i;
        for(j = i + 1; j <= n; j++) 
        {
        	if(r[j].key < r[k].key) {
                k = j;
            }    
        }
        if(i != k) {
            t = r[i];
            r[i] = r[k];
            r[k] = t;
        }
    }
}
```



> 简单选择排序性能分析

对 n 个记录进行简单选择排序，所需要进行的关键字间的比较次数为

![简单选择排序性能分析](图片/简单选择排序性能分析.png)

稳定性分析：不稳定的排序

![稳定性分析](图片/稳定性分析.png)





### 4.3.3、归并排序(Merge Sort)

> 合并2个有序表操作

![合并2个有序表的操作](图片/合并2个有序表的操作.png)

这个操作和归并排序看起来非常像

$T(n) = O(n)$



> 定义

归并排序 —— **将两个或两个以上的有序表组合成一个新的有序表，叫归并排序**



2-路归并排序

排序过程：设初始序列含有 n 个记录则可看成 n 个有序的子序列，每个子序列长度为 1 

两两合并，得到[n / 2]个长度为2或1的有序子序列

再次两两合并，....如此重复，直至得到一个长度为 n 的有序序列为止



例子：

初始关键字： 【49】【38】【65】【97】【76】【13】【27】

一趟归并后：【38 49】【65 97】【13 76】 【27】

二趟归并后：【38 49 65 97】 【13 27 76】

三趟归并后：【13 27 38 49 65 76 97】



> 迭代算法：

将序列的每一个数据看成一个长度为 1 的有序表

然后，将相邻两组进行归并得到长度为2的有序表（一趟归并）

再对相邻两组长度为2的有序表进行下一趟归并得到长度为4的有序表

这样一直下去，直到整个表归并成为有序表



如果某一趟归并中过程中，单出一个表，

该表轮空，参加下一轮归并



> 归并排序来自于递归思想

将无序序列化成大概均等的2个子序列，然后用同样的方法对2个子序列进行归并排序得到2个有序的子序列，再用合并2个有序表的方法合并这2个子序列，得到 n 个元素的有序序列



> 算法描述

```c
void MSort(ElementType A[] ElementType TmpArray[]
          ,int Left, int Right)
{
    int Center;
    if(Left < Right) {	/* 待排序的数据在数组的下标位置 */
        Center = (Left + Right) / 2;
        /* T(N / 2) */
        MSort(A, TmpArray, Left, Center);
        /* T(N / 2) */
        MSort(A, TmpArray, Center +1, Right);
        /* O(N)		*/
		Merge(A, TmpArray, Left, Center + 1, Right);
    }
}
void MergeSort(ElementType A[], int N)
{
    /* need O(n) extra space */
    ElementType *TmpArray;
    TmpArray = malloc(N * sizeof(ElementType));
    if(TmpArray != NULL) {
        MSort(A, TmpArray, 0, N - 1);
        free(TmpArray);
    } else {
        FatalError("No space for tmp array!!!")
    }
}
/* Lpos = start of left half, Rpos = start of right hald  */
void Merge(ElementType A[], ElementType TmpArray[],
          int Lpos, int Rpos, int RightEnd)
{
	int i, LeftEnd, NumElements, TmpPos;
    LeftEnd = Rpos - 1;
    TmpPos = Lpos;
    /* 元素个数 */
    NumElements = RightEnd - Lpos + 1;
    
    while(Lpos <= LeftEnd && Rpos <= RightEnd) /* main loop*/
    {
        // 循环将两个子序列中较小的放入临时数组
   		if(A[Lpos] <= A[Rpos]) {
            TmpArray[TmpPos++] = A[Lpos++];
        } else {
            TmpArray[TmpPos++] = A[Rpos++];
        }
    }
    // 处理没放完的子序列
    while(Lpos <= LeftEnd) /* Copy rest of first half */ 
    {
    	 TmpArray[TmpPos++] = A[Lpos++];
    }
    while(Rpos <= RightEnd) /* Copy rest of second half */
    {
    	  TmpArray[TmpPos++] = A[Rpos++];
    }
  
    for(i = 0; i < NumElements; i++, RightEnd--)
    {  	/* Copy TmpArray back */
        A[RightEnd] = TmpArray[RightEnd];
        printf("%d", A[RightEnd]);
    }
}

```

算法评价

时间复杂度：每一趟归并的时间复杂度为$O(n)$，总共需要归并$log2n$趟，因而，总的时间复杂度为$O(nlog2n)$。

空间复杂度：2-路归并排序过程中，需要一个与表等长的存储单元数组空间，因此空间复杂度为O(n);

![归并排序算法性能](图片/归并排序算法性能.png)



【例题1】将两个各有 n 个元素的有序表归并成一个有序表，其最少比较次数是（A）

A.n	B.2n-1	C.2n	D.n-1

分析：假设有两个有序表 A 和 B 都递增有序，当有序表 A 所有元素均小于有序表 B 的元素时，只需要将 A 的所有元素与 B 的第一个元素比较即可，共比较 n 次。



## 4.4、交换排序(Exchange Sort)

- 交换排序的概念
- 冒泡排序(Bubble Sort)
- 快速排序(Quick Sort)







### 4.4.1、交换排序的概念

> 定义

**通过“交换”无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度**





### 4.4.2、冒泡排序(Bubble Sort)

![冒泡排序过程](图片/冒泡排序过程.png)

> 排序过程：

1. 将第一个记录的关键字与第二个纪录的关键字进行比较，若为逆序`r[1].key > r[2].key`，则交换；然后比较第二个记录与第三个记录；以此类推，直到第 $n - 1$ 个记录和第 $n$ 个记录比较为止 —— 第一趟冒泡排序，结果关键字最大的记录被安置在最后一个记录上
2. 对前 $n - 1$ 个记录进行第二趟冒泡排序，结果使关键字次大的记录被安置在第 $n - 1$ 个记录位置
3. 重复上述过程，直到“在一趟排序中没有进行过交换记录的操作”为止

![冒泡排序例题](图片/冒泡排序例题.png)



算法分析

```c
// 需要排序的结构
typedef struct _Jd
{
    int key;	/* 排序的关键字 */
    double info;
}JD;

void bubble_sort(JD r[], int n)
{
    int m, i, j, flag = 1;
    JD x;
    m = n;
    
    while((m > 1) && flag == 1) 
    {
        flag = 0; /* 本趟是否有交换操作标识初始化 */
        for(j = 1; j < m; j++) /* 本趟将最大元素放到未排序序列的最后 */
        {
            // 相邻元素之间逆序则交换
            if(r[j].key > r[j+1].key) {
            	flag = 1;
                x = r[j];
                r[j] = r[j + 1];
                r[j + 1] = x;
            }
        }
        m--;
    }
}
```



> 算法评价

时间复杂度：

- 最好情况（正序）
- 比较次数： n - 1
- 移动次数：0
- 最坏情况（逆序）
- 比较次数： $=  1/2(n² - n)$
- 移动次数： $= 3/2(n² - n)$

空间复杂度：S(n) = O(1)



> 冒泡排序的改进

1. 冒泡排序的结束条件为最后一趟没有进行“交换记录”。
2. 一般情况下，每次经过一趟“冒泡”，“m - 1”，但并不是每趟都如此

例如： 【5】【2】【3】【1】【9】【7】【8】

​			 【2】【3】【1】【5】**【7】【8】【9】**

​			 【1】【2】【3】【5】【7】【8】【9】

有一个变量指向上次交换的最后一个位置，下一趟我们就从上次交换的位置的前面开始作为我们这一趟“冒泡”最后一个位置就可以了



> 改进后的冒泡排序

```c
void BubbleSort(Elem R[], int n)
{
    int m = n, j;
    while(m > 1)
    {
        int lastExchangeIndex = 1;
        for(j = 0; j < m; j++) 
        {
            if(R[j].key > R[j+1].key) {
                Swap(R[j], R[j + 1]);
                // 记录下进行交换的位置
                lastExchangeIndex = j;
            }
        }
        /* 本趟最后一次进行交换的位置 */
        m = lastExchangeIndex;
    }
}
```



### 4.4.3、快速排序(Quick Sort)

> 定义

快速排序（Quick Sort）是对冒泡排序的一种改进。通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。



> 快速排序算法思想

![快速排序算法思想](图片/快速排序算法思想.png)



例题分析

![快速排序算法例题](图片/快速排序算法例题.png)



如何确定快速排序中的枢纽？

错误的方式：		==Pivot	=	A[ 0 ]==

最糟糕的情况：	A[ ] 有序或者逆序 —— $QuickSort = O(N²)$



安全的方法：	==Privot	=	random select from A[]==

随机数生成很花时间（expensive）



3者取中法：

==Pivot = median (left, center, right)==

这种方法能够排除序列有序的枢纽是最大或者最小值的情况，实际运行时间能够减少约5%.





> 选用第一个关键字作为枢纽

![选用第一个关键字作为枢纽](图片/选用第一个关键字作为枢纽.png)





> 快速排序过程

1. 对$r[s...t]$中记录进行一趟快速排序，附设两个指针 $i$ 和 $j$，设划分元记录

   rp = r[s]，x = rp.key

2. 初始时令 i = s，j = t

3. 首先从 j 所指位置向前搜索第一个关键字小于 x 的记录，并和 rp 交换

4. 再从 i 所指位置起向后搜索，找到第一个关键字大于 x 的记录，和 rp 交换

5. 重复上述第三步和第四步，直到 i == j 为止

6. 再分别对两个子序列进行快速排序，直到每个子序列只含有一个记录为止



- 算法实现

````c
// 需要排序的结构
typedef struct _Jd
{
    int key;	/* 排序的关键字 */
    double info;
}JD;

void qksort(JD r[], int t, int w) // t = low, w = high
{
    int i, j, k;
    JD x;
    // 如果序列中没有元素则无需快排
    if(t >= w) {
         return;
    }
    
    i = t;
    j = w;
    // x作为枢轴值
    x = r[i];
	// 当 i >= j 说明排序已经完成    
    while(i < j)
    {	// 枢轴后面的值大于枢纽
        while((i < j) && (r[j].key >= x.key))
        {
         j--;   
        }
        // 当不满足时，与枢轴交换
        if(i < j) {
            r[i] = r[j];
            i++;
        }
        // 枢轴前面的值小于枢轴 
        while((i < j) && (r[i].key <= x.key))
        {
            i++;
        }
        // 不满足上述条件时，退出循环并交换
        if(i < j) {
        	r[j] = r[i];
            j--;
        }
    }
    r[i] = x;
    qksort(r, t, j - 1);
    qksort(r, j + 1, w);
}
````



> 快速排序算法评价

时间复杂度：

- 最好情况：（每次总是选到中间值作为划分单元）
- $T(n) = O(nlog²n)$
- 最坏情况：（每次总是选到最小或者最大元素作为划分单元）

- $T(n) = O(n^2)$

空间复杂度：

- 需要栈空间以实现递归
- 最坏情况：$S(n) = O(n)$
- 一般情况：$S(n) = O(log^2n)$



三者取中法

![三者取中法](图片/三者取中法.png)

第一个位置 8，中间元素是 6，最后一个元素是0

6 和 0 作交换

input：【8】【1】【4】【9】==【0】==【3】【5】【2】【7】==【6】==

i 指针指向第一个位置， j 指针指向最后一个元素的前面，枢纽不参与交换

|   i   |      |      |       |      |      |       |       |  j   | pivot |
| :---: | :--: | :--: | :---: | :--: | :--: | ----- | :---: | :--: | :---: |
|   8   |  1   |  4   |   9   |  0   |  3   | 5     |   2   |  7   |   6   |
|   i   |      |      |       |      |      |       |   j   |      |       |
| ==2== |  1   |  4   |   9   |  0   |  3   | 5     | ==8== |  7   |   6   |
|       |  i   |  i   |   i   |      |      | j     |       |      |       |
|   2   |  1   |  4   | ==5== |  0   |  3   | ==9== |   8   |  7   |   6   |
|       |      |      |       |  i   |  i   | i     |       |      |       |
|       |      |      |       |      |  j   |       |       |      |       |
|   2   |  1   |  4   |   5   |  0   |  3   | ==6== |   8   |  7   | ==9== |



> 快速排序算法特点

1. 快速排序算法是不稳定的

   对待排序序列 49 <u>49</u> 38 65

   快速排序结果为 38 <u>49</u> 49 65

2. 快速排序的性能跟初始序列中==关键字的排列==和选取的==枢纽==有关

3. 当初始序列按关键字有序（正序或逆序）时，性能最差，退化为冒泡排序，时间复杂度$O(n^2)$

4. 常用“三者取中法”来选取划分记录，即取首记录$r[s].key$尾记录$r[t].key$和中间记录$r[(s + t) / 2].key$三者的中间值作为划分记录
5. 快速排序算法的平均时间复杂度为$O(nlogn)$





**请尝试用三者取中法完成快速排序，并且编写程序与取第一个元素为枢纽的快速排序方法进行比较测试。然后仔细研究快排还可以做哪些改进**



> 快速排序算法的性能

![快速排序算法的性能](图片/快速排序算法的性能.png)



## 4.5、基数排序(Radix Sort)

- 基数排序的概念
- 链式基数排序操作步骤
- 顺序存储结构实现链式基数排序







### 4.5.1、基数排序的概念

基数排序是一种多关键字排序算法。基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的[元素分配](https://baike.baidu.com/item/元素分配/2107419)至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其[时间复杂度](https://baike.baidu.com/item/时间复杂度/1894057)为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。

![多关键字排序](图片/多关键字排序.png)



> 不同优先级优先选择

1. 高位优先多关键字排序

   先对 $K^0$ 进行排序，并按 $K^0$ 不同值将记录序列分成若干子序列之后，分别对 $K^1$ 进行排序，......，依次类推

   直至对最次位关键字 $K^(d-1)$ 排序完成为止

例如：学生记录包含三个关键字

**系别**、**班号**和**班内**的序列号，其中以系别为最主位关键字。

高位优先排序的排序过程

![高位优先排序的排序过程](图片/高位优先排序的排序过程.png)



2. 低位优先多关键字排序

首先按关键字 $K^(d-1)$ 进行排序，然后按关键字 $K^(d-2)$进行排序，......，以此类推，直到最后对最主位关键字$K^0$排序完成为止

低位优先排序的排序过程

![低位优先排序的排序过程](图片/低位优先排序的排序过程.png)



### 4.5.2、链式基数排序操作步骤

初始状态

![链式基数排序操作步骤01](图片/链式基数排序操作步骤01.png)

一趟收集

![链式基数排序操作步骤02](图片/链式基数排序操作步骤02.png)

二趟收集

![链式基数排序操作步骤03](图片/链式基数排序操作步骤03.png)





### 4.5.3、顺序存储结构实现链式基数排序

初始状态

![顺序基数排序操作步骤01](图片/顺序基数排序操作步骤01.png)

一趟收集

![顺序基数排序操作步骤02](图片/顺序基数排序操作步骤02.png)

二趟收集

![顺序基数排序操作步骤03](图片/顺序基数排序操作步骤03.png)







## 4.6、外部排序

- 什么是外部排序
- 外部排序的基本方法
- 预处理
- 两路归并
- 多路归并
- 多阶段归并





### 4.6.1、什么是外部排序

大多数内排序算法都是利用内存是直接访问的事实，读写一个数据是常量的时间。如果输入是在磁带上，磁带上的元素只能顺序访问。甚至数据是在磁盘上，效率还是下降，因为转动磁盘和移动磁头会产生延迟



> 外排序模型

1. 外排序具有设备依赖性。这里考虑的算法工作在磁带上

2. 完成有效的排序至少需要两个磁带机
3. 三个磁带机可以简化问题



### 4.6.2、外部排序的基本方法

由于一次外存操作所需要的时间可以执行数百条甚至上千条指令，因此在外排序中我们主要考虑的是如何==减少外存储器的读写==

在外存上进行排序的最常用方法是利用==归并排序==，因为归并排序只需要访问被归并序列中的第一个元素，这非常适合**顺序文件**

外排序有两个阶段组成：

- 预处理阶段：根据内存的大小将一个有 n 个记录的文件分批读入内存，用各种内排序算法排序，形成一个个有序片段
- 归并阶段：将这些有序片段逐步归并成一个有序文件





### 4.6.3、预处理

> 预处理阶段

- 最简单的方法是**按照内存的容量尽可以多地读入数据记录**，然后在内存中进行排序，排序的结果写入文件中，形成一个已排序片段
- 每次读入的记录数越小，形成的出事的已排序片段越多。而已排序片段越多，归并的次数也越多
- 如果能够让每个初始的已排序片段包含更多的记录，就能减少排序时间。==置换选择==可以让我们在只能容纳 p 个记录的内存中生成平均长度为 2p 的初始的已排序片段



> 置换选择

- 如何更有效地构造已排序片段
- 事实上，只要第一个元素被写到输出磁带上，他所用的内存空间就可以给别的元素使用。如果输入磁带上的下一个元素比刚刚输出的元素大，它能被放入这个已排序片段



置换选择过程

1. 初始时，将 M 个元素读入内存，用一个优先队列存储这 M 个元素。

2. 执行一次取最小元素操作，把最小的元素写入输入磁带。

3. 从输入磁带读入下一个元素。

   1. 如果它比刚才写出去的元素大，则把它加入到优先级队列；
   2. 否则，他不可能进行当前的已排序片段。因为优先级队列比以前少了一个元素，该元素就被放于优先级队列的空余位置

4. 继续这个过程，直到优先级队列的大小为 0，此时该已排序片段结束。

   我们重新构建了一个优先级队列，开始了一个新的已排序片段，此时用了所有存放在空余位置中的元素

![置换选择过程](图片/置换选择过程.png)





### 4.6.4、两路归并

归并有多种方式：两路归并、多路归并和多阶段归并。这里说到两路归并



> 两路归并过程

- 假设我们有四条磁带 A1、A2、B1和B2，两个用于输入，两个用于输出。开始时数据在A1上
- 内存一个能排序 M 个记录
- 工作过程：
  1. 从输入磁带上一次读入 M 个记录，对它们进行内排序，然后把已排序片段轮流写到 B1 和 B2。回绕所有的磁盘。——预处理
  2. 取每条磁带上的第一个已排序片段，把它们归并起来，并把结果写到A1。然后，从每条磁带上取下一个已排序片段，把它们归并起来，结果写到 A2。继续这个过程，轮流把结果写到 A1 和 A2
  3. 回绕四条磁带，重复同样的步骤，这次使用 A 磁带作为输入，而 B磁带作为输出。
  4. 重复步骤二和步骤三，直到剩下一个长度为 N 的已排序片段



初始的磁带排序

![两路归并过程01](图片/两路归并过程01.png)

经过第一轮归并过后的磁带

![两路归并过程02](图片/两路归并过程02.png)

经过第二轮归并后的磁带

![两路归并过程03](图片/两路归并过程03.png)

经过第三轮归并后的磁带

![两路归并过程04](图片/两路归并过程04.png)



> 时间分析

- 算法需要【log(N / M)】次的归并处理，加上初始已排序片段的构造处理。
- 如前例排序13个数据，每个已排序片段长度为3。因此归并次数为3



### 4.6.5、多路归并

- 如果还有额外的磁带，则可以用多路归并（Multiway Merge）或K路归并(K-way Merge)来减少排序输入数据所需要的归并处理次数
- 归并 K 条输入磁带是把每条输入磁带绕到每个已排序片段的开始处实现的。然后找出较小的一个元素，把它放到输出磁带上，相应的输入磁带向前转动
- 归并 K 条输入磁带的问题在于找到K个元素中的最小一个。这稍微有点复杂，我们可以用一个优先级队列来实现。为了得到下一个写入输入磁带上的元素，我们执行一个deleteMin操作。相应的输入磁带向前转动，如果在这条输入磁带上的已排序片段还没完成，我们把这个新元素插入到优先级队列中。



> 多路归并的过程

长度为3 的已排序片段在三条磁带上的初始分布

![多路归并的过程01](图片/多路归并的过程01.png)

经过一轮三路归并后

![多路归并的过程02](图片/多路归并的过程02.png)

经过两轮三路归并后

![多路归并的过程03](图片/多路归并的过程03.png)



> 时间效率

在初始的已排序片段构造阶段后，使用 K 路归并所需的处理次数是【log(N / M)】，因为在每次处理后已排序片段的长度为原来的 k 倍





### 4.6.6、多阶段归并

> 定义

- K 路归并策略需要用 2K条磁带，这可能限制了他在某些应用中的使用
- 我们可以仅用 K + 1 根磁带实现 K 路归并，这称为多阶段归并
- 直观的方法：假设有三条磁带：T1、T2和T3，以及一个在T1上的输入文件，它能产生34个已排序片段
  - 在 T2 和 T3 上各放部分（比如各 17 个）已排序片段，然后把结果归并到 T1
  - 把其中的一部分放到 T2上一执行另一次归并





> 多阶段归并的过程

按非均匀的方法分解原先的 34 个已排序片段

如果把 21 个已排序片段放在 T2，13个已排序片段放在 T3

- 在 T3 为空以前我们能够归并 13 个已排序片段到 T1 上。然后回绕 T1 和 T3
- 并将具有 13 个已排序片段的 T1 和具有 8 个已排序片段的 T2 归并到 T3 上
- 然后归并到 T1 和 T3

![多阶段的已排序片段数](图片/多阶段的已排序片段数.png)





如何分布初始片段

如果已排序片段的数目是一个斐波那契数 Fn，那么分布最好的方法是把它们分解成两个斐波那契数 F(n-1) 和 F(n-2)

否则，为了将已排序片段数增加到一个斐波那契数，必须在磁带上填充虚拟的已排序片段
